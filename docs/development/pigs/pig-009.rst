.. include:: ../../references.txt

.. _pig-009:

***********************
PIG 9 - Event simulator
***********************

* Author: Fabio Pintore, Andrea Giuliani, Axel Donath
* Created: Feb 04, 2019 
* Accepted: 
* Status: 
* Discussion:  

Abstract
========

- create an event simulator 
- required by the CTA Science Tools
- necessary to simulate the DC2


Proposal
========

- the design follows the ASTRIsim simulator
- the latter requests the expected source flux cube for a given spectrum and morphology, prior the application of the IRF
- (to the counts-cube can be associated a light-curve)
- expected background counts cube evaluated from the IRF
- the energy dispersion is applied to the source counts
- the PSF is applied to the source counts
- source and background events are stacked together 
- write them all into an event list file (.fits)

We would like to improve the class presented in general_random_array.py issue. We propose to add the sorting of the cumulative distribution and then we also want to provide an interpolation along the bins. This class has to be extended sampling along a given axis and not along all the array. 

.. code::

    class InverseCDFSampler:
         """Inverse CDF folder"""
         def __init__(self, pdf, random_state=0):
             self.random_state = get_random_state(random_state)
             self.pdf_shape = pdf.shape

             pdf = pdf.ravel() / pdf.sum()
             self.sortindex = np.argsort(pdf, axis=None)

             self.pdf = pdf[self.sortindex]
             self.cdf = np.cumsum(self.pdf)


         def sample(self, size):
             #pick numbers which are uniformly random over the cumulative 
    distribution function
             choice = self.random_state.uniform(high=1, size=size)

             #find the indices corresponding to this point on the CDF
             index = np.searchsorted(self.cdf, choice)
             index = self.sortindex[index]

             # map back to multi-dimensional indexing
             index = np.unravel_index(index, self.pdf_shape)
             index = np.vstack(index)

             index = index + self.random_state.uniform(low=-0.5, high=0.5, 
    size=index.shape)
             return index


We propose a new class labelled as 'MapEventSampler', which takes in input the predicted events, the PSF, energy dispersion and background maps. This includes the methods which implement energy dispersion (
'apply_edisp') and PSF ('apply_psf') corrections, and calculate the background and source events. 

We create a method called 'sample_events' that randomizes the map of predicted source counts to which are then applied the correct PSF and energy dispersion per event. The PSF and Energy dispersion corrections are not taken into account with a loop on the events.


- How does it relate with the MapDataset?


The approach we propose works well only if the resolution in energy and spatial coordinates is very fine, in particular smaller than the IRF energy and PSF resolution. The choice of the map resolution is left to the user.

.. code::

    class MapEventSampler:
         """Map event sampler"""
         def __init__(self, npred_map, psf_map, edisp_map, background_map, 
    random_state=0):
             self.random_state = get_random_state(random_state)
             self.npred = npred

         def npred_total(self):
             return self.random_state.poisson(self.npred.data.sum())

         def apply_edisp(self, events):
             # apply energy dispersion to list of events
             pdf = self.edisp_map.interp_by_coord({"skycoord": events.radec, 
    "energy": events.energy})

             return events

         def apply_psf(self, events):
             # apply psf to list of events
             rad = np.linspace(0, 1 * u.deg, 100)[np.newaxis;, :]
             pdf = self.psf_map.interp_by_coord({"skycoord": events.radec, 
    "energy": events.energy, "rad" rad})

             # sample from pdf along rad axis
             return events

         def sample_background(self):
             # sample from background model without applying IRFs
             return events

         def sample_npred(self):
             n_events = self.npred_total()
             pix_coords = self.cdf_sampler.sample(10 * n_events)
             return self.npred.geom.pix_to_coord(pix_coords[::-1])

         def sample_events(self):
             events = self.sample_npred()
             events = self.apply_psf(events)
             events = self.apply_edisp(events)

             bkg_events = self.sample_background()

             table = vstack(events, bkg_events)
             return EventList(table)


The 'sample()' method returns an astropy table containing source+bkg events.

.. code::

    pdf = Map()

    table = psf.sample(n_samples, ramdoms_state=0)

    sampler = MapEventSampler(pdf)

    table = sample.sample(random_state=0)
 



Alternatives
============


List of proposed pull requests
==============================

- Copy of the stack-overflow code that implements the sampling of n-dimensional discrete probability distributions (details are given in https://stackoverflow.com/questions/21100716/fast-arbitrary-distribution-random-sampling/21101584#21101584)
- We would like to improve the GeneralRandomArray class (details are given in https://github.com/gammapy/gammapy/issues/74)


- Events simulator and IRF corrections




Decision
========


