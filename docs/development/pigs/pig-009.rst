.. include:: ../../references.txt

.. _pig-009:

***********************
PIG 9 - Event simulator
***********************

* Author: Fabio Pintore, Andrea Giuliani, Axel Donath
* Created: May 03, 2019
* Accepted: 
* Status: 
* Discussion:  

Introduction
============

An event simulator of gamma events is of high importance in exploiting the potentiality of the future Cherenkov Telescope
Array (CTA). It will allows us to simulate sources with different spectral and morphological properties adn e.g. investigating
the best configurations for each type of objects and the expected performance of CTA on this data. An event simulator is also listed
as a requirement for the future CTA Science Tools. For this reason, we propose to implement a framework for event simulation
in Gammapy. Based on finely binned input maps, containing the predicted number of counts for a given source with a defined
morphological and spectral model it samples events using the inverse cumulative distribution (Inverse CDF). In addition
a light curve model can be taken into account. Then the proposed simulator will be able to apply the PSF and energy dispersion
to each sampled event. Furthermore, the sampler will include the simulation of background events, again based on finely
binned maps. The final output of the simulator is a stacked event list with source and background events for a given
observation.


A working prototype of the event sample can be found at this URL: https://github.com/fabiopintore/notebooks-public/blob/master/gammapy-event-sampling/prototype.ipynb

Proposal
========

We propose to introduce the following classes to implement the event simulation framework in Gammapy.

InverseCDFSampler
=================

The first building block of the event simulator is a class that samples from a given probability function (PSF). For this
we use the inverse CDF sampling method (https://en.wikipedia.org/wiki/Inverse_transform_sampling). In more detail, it
calculates the cumulative distribution function and, once a set of random numbers is determined, it samples a set of events.
The proposed implementation follows closely what's proposed here https://stackoverflow.com/questions/21100716/fast-arbitrary-distribution-random-sampling/21101584#21101584:

The basic design of the class is as following:

.. code::
	
	from gammapy.utils.distributions import InverseCDFSampler

    pdf = np.array()
	cdf_sampler = InverseCDFSampler(pdf=pdf, random_state=random_state)

Where the `gammapy.utils.random.get_random_state` method is used. The class implements mainly the `.sample()` method
to draw samples from the given pdf:

.. code::
	
	cdf_sampler = InverseCDFSampler()
	samples = cdf_sampler.sample(size=100)

The returned object is a `np.ndarray` containing the sampled indices.

In addition the `InverseCDFSampler` should have the possibility to sample only along a given axis of the PDF. This features is
required to handle sampling of multiple PDFs a the same time to avoid a Python loop over the PDFs. This will be supported
by specifying the `axis` argument:

.. code::

	cdf_sampler = InverseCDFSampler(pdf=pdfs, axis=0)
	samples = cdf_sampler.sample(size=1)


The `InverseCDFSampler` could possibly implement a few helper functions to plot the CDF or PDF. The `InverseCDFSampler`
class will replace the current `GeneralRandom` and `GeneralRandomArray` classes in `gammapy.utils.distributions`.
Possibly the `InverseCDFSampler` needs a to support transforming PDFs e.g. log transformations of power-laws to maintain
accuracy. The need for this is unclear.


MapEventSampler
===============

To support sampling from the predicted number of counts maps for source as well as background maps, we propose to
introduce a `MapEventSampler` class. The responsibility of this class is to handle the physical coordinate transformations,
time dependence of the model, output data structures and sampling of the total number of observed events.

Starting from a predicted number of counts map (e.g. computed by the `MapEvaluator`):

.. code::
	
	src = SkyModel()
	evaluator = MapEvaluator(src, exposure, psf=None, edisp=None)
	npred_map = evaluator.compute_npred()

The `MapEventSampler` takes this map and a lightcurve model as an input and allows to sample from it with the `.sample()`
method:

.. code::

	lightcurve = LightCurveTableModel() # or PhaseCurveTableModel()
	src_sampler = MapEventSampler(npred_map, lightcurve)

    # draw total number of events
    n_events = src_sampler.npred_total()

	# draw events as an astropy table
	events_src = map_sampler.sample()

If no lightcurve is provided a constant rate can be assumed e.g. for background models:

.. code::

	bkg_map = BackgroundModel().map
	bkg_sampler = MapEventSampler(bkg_map, t_min=, t_max=)
	events_bkg = bkg_sample.sample()

It remains to answer the question what to do when the source lightcurve is shorter than the total exposure time: do we
repeat the temporal information or do we just consider the remaining time as a flat or  lightcurve?


IRFMapSampler
=============

We introduce a class that bundles the IRF psf and energy dispersion and applies them to the previously sampled event list. 
In more detail, the class will take as input the `MapEventSampler.sample` source object and then it evaluates a map of 
the psf and the energy dispersion calculated for each event true position and true energy. The reconstructed energies and 
positions are then listed into an astropy table. We propose two different options to accomplish this task, which should work 
as follows:

.. code::

	events = vstack([events_src_1, events_src_2, ..., events_src_N])
	irf_sampler = IRFMapSampler(events, psf_map, edisp_map)
	events_obs = irf_sampler.sample()

	# or

	irf_sampler = IRFMapSampler(psf_map, edisp_map)
	events = irf_sampler.sample_psf(events)
	events = irf_sampler.sample_edisp(events)

In the first case, the IRF is applied to the stacking of all the simulated sources, with the `IRFSampler` class which
contains only the `sample` method. In the second case, the `IRFSampler` reads the psf and energy maps only, and then 
it contains two methods that apply separately the psf and edisp corrections to the events; for more than one simulated 
source, a loop will be needed.


MapDatasetEventSampler?
=======================

Propose high level structure:

.. code::
    
    dataset_sampler = MapDatasetEventSampler(dataset)
    events = dataset_sampler.sample()

    # or alternatively

    events = dataset.sample_events()


More detailed:

.. code::

    events = []

    # sample from source components
    for evaluator in dataset._evaluators:
        evaluator.psf = None?
        evaluator.edisp = None?
        npred = evaluator.compute_npred()

        sampler = MapEventSampler(npred)

        # set an ID for the source component?
        
        events.append(sampler.sample())

    events_stacked = vstack(events)

    # apply IRFs
    irf_sampler = IRFSampler(events_stacked, dataset.psf_map, dataset.edisp_map)
    events_reco = irf_sampler.sample()

    # sample from background
    bkg_sampler = MapEventSampler(dataset.background_model.map)
    events_bkg = bkg_sampler.sample()

    events_total = vstack([events_reco, event_bkg])




Alternatives
============

Use the ctools sampler for data challenge?
Use the ASTRI sampler and write in a format compatible with Gammapy? 
Always use binned simulation?


List of proposed pull requests
==============================

This is a proposal for a list of pull requests implementing the proposed changes, ordered by priority:

1. Introduce the InverseCDFSampler.
2. Dismiss the ``general_random`` class in gammapy.utils.distributions.
3. Implement the InverseCDFSampler into gammapy.utils.distributions (Gammapy v.0.12).
4. Introduce the MapEventSampler class.
5. Implement MapEventSampler into gammapy. ... (v.0.12).?
6. Introduce the IRFSampler class.
7. Implement IRFSampler into gammapy. ... (v.0.12). ?


Decision
========






