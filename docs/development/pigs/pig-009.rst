.. include:: ../../references.txt

.. _pig-009:

***********************
PIG 9 - Event simulator
***********************

* Author: Fabio Pintore, Andrea Giuliani, Axel Donath
* Created: Feb 04, 2019 
* Accepted: 
* Status: 
* Discussion:  

Introduction
============

An event simulator of gamma events is of high importance in exploiting the potentiality of the future Cherenkov Telescope
Array (CTA). It will allows us to simulate sources with different spectral and morphological properties, hence investigating
the best configurations for each type of objects and the expected performances of CTA. We note that an event simulator is
currently required by the CTA Science Tools. In addition, there will be the possibility to adopt it to simulate the next
CTA Data Challenge (DC2). Therefore, we propose to create an event simulator which sample random events for given sources.
It will need input maps where spatial morphology and spectral distributions are provided, and optionally also the time 
variability will be given. Then the proposed simulator will be able to apply the PSF and energy dispersion, for each simulated observation, to correct position and energy of the sampled events. Source lightcurves will be also taken into account to 
simulate temporal variations. Furthermore, the sampler will possibly include the simulation of background events. The output
of the simulator is an astropy table. A link to a Jupyter event sampler prototype can be found at this URL: https://github.com/fabiopintore/notebooks-public/blob/master/gammapy-event-sampling/prototype.ipynb

Proposal
========

We propose to introduce the following classes to implement the simulator in Gammapy.

InverseCDFSampler
=================

The first step of an event simulator can be obtained by developing a sampler of the cumulative distribution function for
a given input probability distribution function. In more detail, it calculates the cumulative distribution function and,
once a set of random numbers is determined, it samples a set of events.

The basic design of the class works as following:

.. code::
	
	from gammapy.utils.distributions import InverseCDFSampler
	cdf_sampler = InverseCDFSampler(pdf=npred_map.data, axis=None, random_state=random_state)

Where the `gammapy.utils.random.get_random_state` method is used. The class implements the following methods:

.. code::
	
	cdf_sampler = InverseCDFSampler()
	cdf_sampler.sample_axis()
	cdf_sampler.sample()

That will allow us to sample alternatively along all the axes or a given axis of the input map.


MapEventSampler
===============

The next fundamental step is the creation of a map of the predicted events. This can be performed, for a given exposure time, 
with the `MapDataset` class which takes as input a `Skymodel` object. The predicted event map is then the input of the new 
proposed class `MapEventSampler`. The same approach can be applied to the background events. The source events will be simulated 
as following:

.. code::
	
	src = SkyModel()
	evaluator = MapEvaluator(src, exposure, psf=None, edisp=None)
	npred_map = evaluator.compute_npred()

	src_sampler = MapEventSampler(npred_map, lightcurve) 
	events_src = map_sampler.sample()
	# events_src is an astropy table

	bkg_map = Map()
	bkg_sampler = MapEventSampler(npred_map, bkg_map, exposure)
	events_bkg = bkg_sample.sample()

Where the `MapEventSampler` class can be used to generate alternatively source or background events. It is important to note 
that the `MapEventSampler` takes into account the temporal information (lightcurve) for the source, while for the background 
the time of events arrival are sampled evenly along the whole exposure time. It remains to answer the question what to do when 
the source lightcurve is shorter than the total exposure time: do we repeat the temporal information or do we just consider the remaining time as a flat lightcurve?


IRFMapSampler
=============

We introduce a class that bundles the IRF psf and energy dispersion and applies them to the previously sampled event list. 
In more detail, the class will take as input the `MapEventSampler.sample` source object and then it evaluates a map of 
the psf and the energy dispersion calculated for each event true position and true energy. The reconstructed energies and 
positions are then listed into an astropy table. We propose two different options to accomplish this task, which should work 
as follows:

.. code::

	events = vstack([events_src_1, events_src_2, ..., events_src_N])
	irf_sampler = IRFMapSampler(events, psf_map, edisp_map)
	events_obs = irf_sampler.sample()

	# or

	irf_sampler = IRFMapSampler(psf_map, edisp_map)
	events = irf_sampler.sample_psf(events)
	events = irf_sampler.sample_edisp(events)

In the first case, the IRF is applied to the stacking of all the simulated sources, with the `IRFSampler` class which
contains only the `sample` method. In the second case, the `IRFSampler` reads the psf and energy maps only, and then 
it contains two methods that apply separately the psf and edisp corrections to the events; for more than one simulated 
source, a loop will be needed.


MapDatasetEventSampler?
=======================

Propose high level structure:

.. code::
    
    dataset_sampler = MapDatasetEventSampler(dataset)
    events = dataset_sampler.sample()

    # or alternatively

    events = dataset.sample_events()


More detailed:

.. code::

    events = []

    # sample from source components
    for evaluator in dataset._evaluators:
        evaluator.psf = None?
        evaluator.edisp = None?
        npred = evaluator.compute_npred()

        sampler = MapEventSampler(npred)

        # set an ID for the source component?
        
        events.append(sampler.sample())

    events_stacked = vstack(events)

    # apply IRFs
    irf_sampler = IRFSampler(events_stacked, dataset.psf_map, dataset.edisp_map)
    events_reco = irf_sampler.sample()

    # sample from background
    bkg_sampler = MapEventSampler(dataset.background_model.map)
    events_bkg = bkg_sampler.sample()

    events_total = vstack([events_reco, event_bkg])




Alternatives
============

Use the ctools sampler for data challenge?
Use the ASTRI sampler and write in a format compatible with Gammapy? 
Always use binned simulation?


List of proposed pull requests
==============================

This is a proposal for a list of pull requests implementing the proposed changes, ordered by priority:

1. Introduce the InverseCDFSampler.
2. Dismiss the ``general_random`` class in gammapy.utils.distributions.
3. Implement the InverseCDFSampler into gammapy.utils.distributions (Gammapy v.0.12).
4. Introduce the MapEventSampler class.
5. Implement MapEventSampler into gammapy. ... (v.0.12).?
6. Introduce the IRFSampler class.
7. Implement IRFSampler into gammapy. ... (v.0.12). ?


Decision
========






