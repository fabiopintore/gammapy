.. include:: ../../references.txt

.. _pig-009:

***********************
PIG 9 - Event simulator
***********************

* Author: Fabio Pintore, Andrea Giuliani, Axel Donath
* Created: Feb 04, 2019 
* Accepted: 
* Status: 
* Discussion:  

Introduction
============

An event simulator of gamma events is of high importance in exploiting the potentiality of the future Cherenkov Telescope
Array (CTA). It will allows us to simulate sources with different spectral and morphological properties, hence investigating
the best configurations for each type of objects and the expected performances of CTA. We note that an event simulator is
currently required by the CTA Science Tools. In addition, there will be the possibility to adopt it to simulate the next
CTA Data Challenge (DC2). Therefore, we propose to create an event simulator which sample random events for given sources.
It will need input maps where spatial morphology and spectral distributions are provided. Then the proposed simulator will
be able to apply the PSF and energy dispersion, for each simulated observation, to correct position and energy of the sampled
events. Source lightcurves will be also taken into account to simulate temporal variations. Furthermore, the sampler will
possibly include the simulation of background events. The output of the simulator is an astropy table.

Proposal
========

We propose to introduce the following classes to implement the simulator in Gammapy:

InverseCDFSampler
=================

The first step of an event simulator can be obtained by developing a sampler of the cumulative distribution function for
a given input probability distribution function. In more detail, it calculates the cumulative distribution function and,
once a set of random numbers is determined, it samples a set of events.

The basic design of the class works as following:

	from gammapy.utils.distributions import InverseCDFSampler

	cdf_sampler = InverseCDFSampler(pdf=npred_map.data, axis=None, random_state=random_state)

where the gammapy.utils.random.get_random_state method is used.


The class implements the following methods:

	cdf_sampler = InverseCDFSampler()

	cdf_sampler.sample_axis()

	cdf_sampler.sample()


that will allow us to sample alternatively along all the axes or a given axis of the input map.


MapEventSampler
===============

src = SkyModel()
evaluator = MapEvaluator(src, exposure, psf=None, edisp=None)
npred_map = evaluator.compute_npred()

src_sampler = MapEventSampler(npred_map, psf_map, edisp_map)
events_src = map_sampler.sample()
# events_src is an astropy table

bkg_map = Map()
bkg_sampler = MapEventSampler(bkg_map, psf_map=None, edisp_map=None)
events_bkg = bkg_sample.sample()


IRFMapSampler
=============

events = vstack([events_src_1, events_src_2, ..., events_src_N])
irf_sampler = IRFSampler(events, psf_map, edisp_map)
events_obs = irf_sampler.sample()

# or

irf_sampler = IRFSampler(psf_map, edisp_map)
events = irf_sampler.sample_psf(events)
events = irf_sampler.sample_edisp(events)



MapDatasetEventSampler?
=======================

Propose high level structure:

    dataset_sampler = MapDatasetEventSampler(dataset)
    events = dataset_sampler.sample()

    # or alternatively

    events = dataset.sample_events()


More detailed:

    events = []

    # sample from source components
    for evaluator in dataset._evaluators:
        evaluator.psf = None?
        evaluator.edisp = None?
        npred = evaluator.compute_npred()

        sampler = MapEventSampler(npred)

        # set an ID for the source component?
        
        events.append(sampler.sample())

    events_stacked = vstack(events)

    # apply IRFs
    irf_sampler = IRFSampler(events_stacked, dataset.psf_map, dataset.edisp_map)
    events_reco = irf_sampler.sample()

    # sample from background
    bkg_sampler = MapEventSampler(dataset.background_model.map)
    events_bkg = bkg_sampler.sample()

    events_total = vstack([events_reco, event_bkg])




Alternatives
============

Use the ctools sampler for data challenge?
Use the ASTRI sampler and write in a format compatible with Gammapy? 
Always use binned simulation?


List of proposed pull requests
==============================

This is a proposal for a list of pull requests implementing the proposed changes, ordered by priority:

1. Introduce the InverseCDFSampler.
2. Dismiss the ``general_random`` class in gammapy.utils.distributions.
3. Implement the InverseCDFSampler into gammapy.utils.distributions (Gammapy v.0.12).


Decision
========













#####################################
- the design follows the ASTRIsim simulator
- the latter requests the expected source flux cube for a given spectrum and morphology, prior the application of the IRF
- (to the counts-cube can be associated a light-curve)
- expected background counts cube evaluated from the IRF
- the energy dispersion is applied to the source counts
- the PSF is applied to the source counts
- source and background events are stacked together 
- write them all into an event list file (.fits)

We propose to create an event simulator based on Gammapy, which is needed for the Science Tools, and it would allow a valid alternative to ctobssim. 
We designed our simulator exploiting the already available ASTRI simulator (ASTRIsim), written in IDL. ASTRIsim starts from an input source flux cube (possibly associated to a spatial map), gives a set of simulated events (with associated positions, energies and times). Furthermore, there is possibility to provide an input light-curve to take into account source time variability.


We would like to improve the class presented in general_random_array.py issue. We propose to add the sorting of the cumulative distribution and then we also want to provide an interpolation along the bins. This class has to be extended sampling along a given axis and not along all the array. 

.. code::

    class InverseCDFSampler:
         """Inverse CDF folder"""
         def __init__(self, pdf, random_state=0):
             self.random_state = get_random_state(random_state)
             self.pdf_shape = pdf.shape

             pdf = pdf.ravel() / pdf.sum()
             self.sortindex = np.argsort(pdf, axis=None)

             self.pdf = pdf[self.sortindex]
             self.cdf = np.cumsum(self.pdf)


         def sample(self, size):
             #pick numbers which are uniformly random over the cumulative 
    distribution function
             choice = self.random_state.uniform(high=1, size=size)

             #find the indices corresponding to this point on the CDF
             index = np.searchsorted(self.cdf, choice)
             index = self.sortindex[index]

             # map back to multi-dimensional indexing
             index = np.unravel_index(index, self.pdf_shape)
             index = np.vstack(index)

             index = index + self.random_state.uniform(low=-0.5, high=0.5, 
    size=index.shape)
             return index


We propose a new class labelled as 'MapEventSampler', which takes in input the predicted events, the PSF, energy dispersion and background maps. This includes the methods which implement energy dispersion (
'apply_edisp') and PSF ('apply_psf') corrections, and calculate the background and source events. 

We create a method called 'sample_events' that randomizes the map of predicted source counts to which are then applied the correct PSF and energy dispersion per event. The PSF and Energy dispersion corrections are not taken into account with a loop on the events.




- to discuss: introduce the time of each event. In this moment, we just provide a counts-cube for all the components, but this does not allow us to associate the events to different light-curves. --> solution: create counts-cube for each component, apply the light-curve, and then stack all the components...

The approach we propose works well only if the resolution in energy and spatial coordinates is very fine, in particular smaller than the IRF energy and PSF resolution. The choice of the map resolution is left to the user.

.. code::

    class MapEventSampler:
         """Map event sampler"""
         def __init__(self, npred_map, psf_map, edisp_map, background_map, 
    random_state=0):
             self.random_state = get_random_state(random_state)
             self.npred = npred

         def npred_total(self):
             return self.random_state.poisson(self.npred.data.sum())

         def apply_edisp(self, events):
             # apply energy dispersion to list of events
             pdf = self.edisp_map.interp_by_coord({"skycoord": events.radec, 
    "energy": events.energy})

             return events

         def apply_psf(self, events):
             # apply psf to list of events
             rad = np.linspace(0, 1 * u.deg, 100)[np.newaxis;, :]
             pdf = self.psf_map.interp_by_coord({"skycoord": events.radec, 
    "energy": events.energy, "rad" rad})

             # sample from pdf along rad axis
             return events

         def sample_background(self):
             # sample from background model without applying IRFs
             return events

         def sample_npred(self):
             n_events = self.npred_total()
             pix_coords = self.cdf_sampler.sample(10 * n_events)
             return self.npred.geom.pix_to_coord(pix_coords[::-1])

         def sample_events(self):
             events = self.sample_npred()
             events = self.apply_psf(events)
             events = self.apply_edisp(events)

             bkg_events = self.sample_background()

             table = vstack(events, bkg_events)
             return EventList(table)


- Copy of the stack-overflow code that implements the sampling of n-dimensional discrete probability distributions (details are given in https://stackoverflow.com/questions/21100716/fast-arbitrary-distribution-random-sampling/21101584#21101584)
- We would like to improve the GeneralRandomArray class (details are given in https://github.com/gammapy/gammapy/issues/74)


- Events simulator and IRF corrections

